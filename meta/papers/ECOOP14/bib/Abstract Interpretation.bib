Automatically generated by Mendeley Desktop 1.10.1
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@inproceedings{Cousot1977,
abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the resulta of abstract execution give some informations on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515*17 may be undestood to denote computations on the abstract universe \{(+), (-), (+-)\} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515*17 ==> -(+)*(+) ==> (-)*(+) ==> (-), proves that -1515+17 is a negative number. Abstract interpretation is concerned by a particlar underlying structure of the usual universe of computations (the sign, in our example). It gives a summay of some facets of the actual executions of a program. In general this summary is simple to obtain but inacurrate (e.g. -1515+17 ==> -(+)+(+) ==> (-)+(+) ==> (+-)). Despite its fundamental incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, ...).},
address = {New York, New York, USA},
author = {Cousot, Patrick and Cousot, Radhia},
booktitle = {Proc. 4th ACM SIGACT-SIGPLAN Symp. Princ. Program. Lang. - POPL '77},
doi = {10.1145/512950.512973},
file = {:Users/danielefilaretti/Library/Application Support/Mendeley Desktop/Downloaded/Cousot, Cousot - 1977 - Abstract interpretation.pdf:pdf},
keywords = {abstract interpretation},
mendeley-tags = {abstract interpretation},
pages = {238--252},
publisher = {ACM Press},
title = {{Abstract interpretation}},
url = {http://dl.acm.org/citation.cfm?id=512973 http://portal.acm.org/citation.cfm?doid=512950.512973},
year = {1977}
}
@inproceedings{VanHorn2010,
abstract = {We describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well-established abstract machines. To demonstrate the tech- nique and support our claim, we transform the CEK machine of Felleisen and Friedman, a lazy variant of Krivine’s machine, and the stack-inspecting CM machine of Clements and Felleisen into abstract interpretations of themselves. The resulting analyses bound temporal ordering of program events; predict return-flow and stack-inspection behavior; and approximate the flow and eval- uation of by-need parameters. For all of these machines, we find that a series of well-known concrete machine refactorings, plus a technique we call store-allocated continuations, leads to machines that abstract into static analyses simply by bounding their stores. We demonstrate that the technique scales up uniformly to allow static analysis of realistic language features, including tail calls, conditionals, side effects, exceptions, first-class continuations, and even garbage collection.},
address = {New York, New York, USA},
author = {{Van Horn}, David and Might, Matthew},
booktitle = {Proc. 15th ACM SIGPLAN Int. Conf. Funct. Program. - ICFP '10},
doi = {10.1145/1863543.1863553},
file = {:Users/danielefilaretti/Library/Application Support/Mendeley Desktop/Downloaded/Van Horn, Might - 2010 - Abstracting abstract machines.pdf:pdf},
isbn = {9781605587943},
keywords = {abstract interpretation,abstract machines,program analysis,theory},
mendeley-tags = {abstract interpretation,program analysis,theory},
pages = {51},
publisher = {ACM Press},
title = {{Abstracting abstract machines}},
url = {http://portal.acm.org/citation.cfm?doid=1863543.1863553},
year = {2010}
}
@article{Arusoaie2012b,
abstract = {Symbolic execution is a well-known program analysis technique introduced in 1976 by James C. King [11]. Since then, it has proved its usefulness for testing, verifying, and debugging programs. Symbolic execution consists in providing programs with symbolic inputs, instead of concrete ones, and the execution is performed by processing expressions involving the symbolic inputs [19]. The main advantage of symbolic execution is that it allows reasoning about multiple concrete executions of a program, and its main disadvantage is the state space explosion determined by decision statements and loops. Recently, the technique has found renewed interest in the formal methods community due to new algorithmic developments and progress in decision procedures. Current applications of symbolic execution include automated test input generation [13], [26], invariant detection [18], model checking [10], or proving program partial correctness [25], [6]. The state of a symbolic program execution typically contains the next statement to be exe- cuted, symbolic values of program variables, and the path condition, which constrains past and present values of those variables (i.e., constraints on the symbolic values are accumulated on the path taken by the execution for reaching the current instruction). The states, and the transi- tions between them, generate a symbolic execution tree.When the control flow of a program is determined by symbolic values (e.g., the next instruction to be executed is a if-statement, whose Boolean condition depends on symbolic values), then there is a branching in the tree. The path condition is then used to discriminate among branches. Two of the most important properties expected of symbolic execution are: Coverage:for every concrete execution there is a corresponding symbolic one; Precision:for every symbolic execution there is a corresponding concrete one; where two executions are said to be corresponding if they take the same path. In this paper we propose a generic, language independent symbolic execution approach that, under some reasonable conditions, has the above properties.},
author = {Arusoaie, Andrei and Lucanu, Dorel and Rusu, Vlad},
file = {:Users/danielefilaretti/Library/Application Support/Mendeley Desktop/Downloaded/Arusoaie, Lucanu, Rusu - 2012 - A Generic Framework for Symbolic Execution.pdf:pdf},
number = {December},
title = {{A Generic Framework for Symbolic Execution}},
url = {http://hal.inria.fr/docs/00/76/78/17/PDF/symbexec-techreport.pdf},
year = {2012}
}
@phdthesis{Asavoae2012,
abstract = {This dissertation shows how abstract interpretation’s view of program analysis and ver- ification can be instilled in theKframework in a generic fashion as reflective semantics. Kis a rewriting-based framework dedicated to defining executable specifications for programming languages semantics. The definitional style proposed by theKframework is an amalgamation of features from different semantics (e.g., features from operational semantics, continuation based semantics, denotational semantics, a.s.o.). The current K’s desideratum is to demonstrate that its formal specification environment can be ef- fectively used for various classes of programming languages paradigms. Abstract interpretation provides a well known, standardized and extensively used framework for program analysis and verification. The main idea in abstract interpre- tation is that program analysis and verification can be achieved by applying fixpoint iterators over sound approximations of program semantics. Solely from a semantics perspective, abstract interpretation is a reflective semantics environment where the re- flexion of the semantics is called abstraction. The program analysis and verification approaches tackled in K are either model checking, achieved via Maude’s LTL model checker, or deductive verification, achieved via matching logic. However, the third major verification technique, namely abstract interpretation, was not systematically approached in K. Our thesis addresses this omis- sion and covers it. As such, we design a generic method for defining in K abstract specifications of pushdown systems and fixpoint iterators over these specifications. We demonstrate the efficiency of this design by instantiating it with three case studies of abstractions for data analysis, alias analysis, and shape analysis.},
author = {Asavoae, Irina Mariuca},
file = {:Users/danielefilaretti/Library/Application Support/Mendeley Desktop/Downloaded/Asavoae - 2012 - K Semantics for Abstractions (PhD Thesis).pdf:pdf},
keywords = {K,abstract interpretation},
mendeley-tags = {K,abstract interpretation},
school = {UNIVERSITY ALEXANDRU IOAN CUZA, IAS 2012},
title = {{K Semantics for Abstractions (PhD Thesis)}},
year = {2012}
}
@article{Cousot,
author = {Cousot, Patrick},
file = {:Users/danielefilaretti/Library/Application Support/Mendeley Desktop/Downloaded/Cousot - Unknown - « A Tutorial on Abstract Interpretation » Static analysis by abstract interpretation.pdf:pdf},
keywords = {abstract interpretation,slides},
mendeley-tags = {abstract interpretation,slides},
title = {{« A Tutorial on Abstract Interpretation » Static analysis by abstract interpretation}}
}
