First of all, we'd like to apologize for the embarrassing number of typos. We rushed to make the deadline, because we felt ECOOP was the ideal venue for this paper. We thank the reviewers for their helpful feedback, and the patience shown in pointing out the typos. Reviewers 3 and 4 were rightly confused by the example on page 8. It contained a typo: "$v===$obj1->b" should have been "$v===$obj1->a" (we've also improved the explanation).

Reviewer 3 declares not being much into mechanized formal semantics of programming languages, and not being particularly interested in PHP. He asks what general lesson could he learn from our paper. We are delighted that such a reviewer still chose "An executable formal semantics of PHP", and found some value in it. We believe that formalists, who prefer working on simplified models, will learn from our design and validation methodology how to extend their formalizations to real-world languages, increasing the potential impact of their research. Conversely, practitioners will learn how a formal semantics can help them fully understand the behaviour of a programming language, supporting the development of sound analysis tools and better language implementations. 

Reviewer 3 also says "I want to see more concrete stories about how the particular formal semantics of the authors lead to better static analyses or testing tools." Reviewer 4 comments: "The two case studies presented are interesting. However, a lager body of case studies, possibly showing flaws in some PHP library would make the contribution of the paper more interesting." We agree that our semantics should lead to build better static analyses and testing tools for PHP, and that we should collect a large body of case studies highlighting flaws in PHP libraries. This is indeed the ambitious goal of our multi-year research programme. The main contribution of this paper is in developing the formal semantics of PHP, thoroughly validated by testing, that will enable such outcomes. The case studies of Section 5, in our view, add value to the semantic development, concretely pointing the way to future work. 

Reviewer 3 reports being "slightly disappointed that the case studies did not involve strange features of PHP described in the first part of the paper." We prioritized using typical PHP code from 3rd party libraries, rather than artificial examples targeted to the strange features. In order to support sound analyses, it is important to model obscure corner cases in the semantics, although they occur relatively seldom in widely deployed code. Our analysis methods do work also for the strange PHP features.

Reviewer 3 also comments: "I really like the idea of automatic generation of a regression test suite described in the footnote. If this had been done, I would have strongly supported the paper." We believe that the right approach may involve automatic test generation for the interpreter based on symbolic execution, combined with grammatical evolution (to guide the generation of test inputs towards program-like strings). That would be an altogether different research project, best left for others to pursue.